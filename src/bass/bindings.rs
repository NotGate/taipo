/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const BASSVERSION: u32 = 516;
pub const BASSVERSIONTEXT: &'static [u8; 4usize] = b"2.4\0";
pub const BASS_OK: u32 = 0;
pub const BASS_ERROR_MEM: u32 = 1;
pub const BASS_ERROR_FILEOPEN: u32 = 2;
pub const BASS_ERROR_DRIVER: u32 = 3;
pub const BASS_ERROR_BUFLOST: u32 = 4;
pub const BASS_ERROR_HANDLE: u32 = 5;
pub const BASS_ERROR_FORMAT: u32 = 6;
pub const BASS_ERROR_POSITION: u32 = 7;
pub const BASS_ERROR_INIT: u32 = 8;
pub const BASS_ERROR_START: u32 = 9;
pub const BASS_ERROR_SSL: u32 = 10;
pub const BASS_ERROR_ALREADY: u32 = 14;
pub const BASS_ERROR_NOTAUDIO: u32 = 17;
pub const BASS_ERROR_NOCHAN: u32 = 18;
pub const BASS_ERROR_ILLTYPE: u32 = 19;
pub const BASS_ERROR_ILLPARAM: u32 = 20;
pub const BASS_ERROR_NO3D: u32 = 21;
pub const BASS_ERROR_NOEAX: u32 = 22;
pub const BASS_ERROR_DEVICE: u32 = 23;
pub const BASS_ERROR_NOPLAY: u32 = 24;
pub const BASS_ERROR_FREQ: u32 = 25;
pub const BASS_ERROR_NOTFILE: u32 = 27;
pub const BASS_ERROR_NOHW: u32 = 29;
pub const BASS_ERROR_EMPTY: u32 = 31;
pub const BASS_ERROR_NONET: u32 = 32;
pub const BASS_ERROR_CREATE: u32 = 33;
pub const BASS_ERROR_NOFX: u32 = 34;
pub const BASS_ERROR_NOTAVAIL: u32 = 37;
pub const BASS_ERROR_DECODE: u32 = 38;
pub const BASS_ERROR_DX: u32 = 39;
pub const BASS_ERROR_TIMEOUT: u32 = 40;
pub const BASS_ERROR_FILEFORM: u32 = 41;
pub const BASS_ERROR_SPEAKER: u32 = 42;
pub const BASS_ERROR_VERSION: u32 = 43;
pub const BASS_ERROR_CODEC: u32 = 44;
pub const BASS_ERROR_ENDED: u32 = 45;
pub const BASS_ERROR_BUSY: u32 = 46;
pub const BASS_ERROR_UNSTREAMABLE: u32 = 47;
pub const BASS_ERROR_UNKNOWN: i32 = -1;
pub const BASS_CONFIG_BUFFER: u32 = 0;
pub const BASS_CONFIG_UPDATEPERIOD: u32 = 1;
pub const BASS_CONFIG_GVOL_SAMPLE: u32 = 4;
pub const BASS_CONFIG_GVOL_STREAM: u32 = 5;
pub const BASS_CONFIG_GVOL_MUSIC: u32 = 6;
pub const BASS_CONFIG_CURVE_VOL: u32 = 7;
pub const BASS_CONFIG_CURVE_PAN: u32 = 8;
pub const BASS_CONFIG_FLOATDSP: u32 = 9;
pub const BASS_CONFIG_3DALGORITHM: u32 = 10;
pub const BASS_CONFIG_NET_TIMEOUT: u32 = 11;
pub const BASS_CONFIG_NET_BUFFER: u32 = 12;
pub const BASS_CONFIG_PAUSE_NOPLAY: u32 = 13;
pub const BASS_CONFIG_NET_PREBUF: u32 = 15;
pub const BASS_CONFIG_NET_PASSIVE: u32 = 18;
pub const BASS_CONFIG_REC_BUFFER: u32 = 19;
pub const BASS_CONFIG_NET_PLAYLIST: u32 = 21;
pub const BASS_CONFIG_MUSIC_VIRTUAL: u32 = 22;
pub const BASS_CONFIG_VERIFY: u32 = 23;
pub const BASS_CONFIG_UPDATETHREADS: u32 = 24;
pub const BASS_CONFIG_DEV_BUFFER: u32 = 27;
pub const BASS_CONFIG_REC_LOOPBACK: u32 = 28;
pub const BASS_CONFIG_VISTA_TRUEPOS: u32 = 30;
pub const BASS_CONFIG_IOS_SESSION: u32 = 34;
pub const BASS_CONFIG_IOS_MIXAUDIO: u32 = 34;
pub const BASS_CONFIG_DEV_DEFAULT: u32 = 36;
pub const BASS_CONFIG_NET_READTIMEOUT: u32 = 37;
pub const BASS_CONFIG_VISTA_SPEAKERS: u32 = 38;
pub const BASS_CONFIG_IOS_SPEAKER: u32 = 39;
pub const BASS_CONFIG_MF_DISABLE: u32 = 40;
pub const BASS_CONFIG_HANDLES: u32 = 41;
pub const BASS_CONFIG_UNICODE: u32 = 42;
pub const BASS_CONFIG_SRC: u32 = 43;
pub const BASS_CONFIG_SRC_SAMPLE: u32 = 44;
pub const BASS_CONFIG_ASYNCFILE_BUFFER: u32 = 45;
pub const BASS_CONFIG_OGG_PRESCAN: u32 = 47;
pub const BASS_CONFIG_MF_VIDEO: u32 = 48;
pub const BASS_CONFIG_AIRPLAY: u32 = 49;
pub const BASS_CONFIG_DEV_NONSTOP: u32 = 50;
pub const BASS_CONFIG_IOS_NOCATEGORY: u32 = 51;
pub const BASS_CONFIG_VERIFY_NET: u32 = 52;
pub const BASS_CONFIG_DEV_PERIOD: u32 = 53;
pub const BASS_CONFIG_FLOAT: u32 = 54;
pub const BASS_CONFIG_NET_SEEK: u32 = 56;
pub const BASS_CONFIG_AM_DISABLE: u32 = 58;
pub const BASS_CONFIG_NET_PLAYLIST_DEPTH: u32 = 59;
pub const BASS_CONFIG_NET_PREBUF_WAIT: u32 = 60;
pub const BASS_CONFIG_ANDROID_SESSIONID: u32 = 62;
pub const BASS_CONFIG_WASAPI_PERSIST: u32 = 65;
pub const BASS_CONFIG_REC_WASAPI: u32 = 66;
pub const BASS_CONFIG_ANDROID_AAUDIO: u32 = 67;
pub const BASS_CONFIG_NET_AGENT: u32 = 16;
pub const BASS_CONFIG_NET_PROXY: u32 = 17;
pub const BASS_CONFIG_IOS_NOTIFY: u32 = 46;
pub const BASS_CONFIG_LIBSSL: u32 = 64;
pub const BASS_IOS_SESSION_MIX: u32 = 1;
pub const BASS_IOS_SESSION_DUCK: u32 = 2;
pub const BASS_IOS_SESSION_AMBIENT: u32 = 4;
pub const BASS_IOS_SESSION_SPEAKER: u32 = 8;
pub const BASS_IOS_SESSION_DISABLE: u32 = 16;
pub const BASS_DEVICE_8BITS: u32 = 1;
pub const BASS_DEVICE_MONO: u32 = 2;
pub const BASS_DEVICE_3D: u32 = 4;
pub const BASS_DEVICE_16BITS: u32 = 8;
pub const BASS_DEVICE_LATENCY: u32 = 256;
pub const BASS_DEVICE_CPSPEAKERS: u32 = 1024;
pub const BASS_DEVICE_SPEAKERS: u32 = 2048;
pub const BASS_DEVICE_NOSPEAKER: u32 = 4096;
pub const BASS_DEVICE_DMIX: u32 = 8192;
pub const BASS_DEVICE_FREQ: u32 = 16384;
pub const BASS_DEVICE_STEREO: u32 = 32768;
pub const BASS_DEVICE_HOG: u32 = 65536;
pub const BASS_DEVICE_AUDIOTRACK: u32 = 131072;
pub const BASS_DEVICE_DSOUND: u32 = 262144;
pub const BASS_OBJECT_DS: u32 = 1;
pub const BASS_OBJECT_DS3DL: u32 = 2;
pub const BASS_DEVICE_ENABLED: u32 = 1;
pub const BASS_DEVICE_DEFAULT: u32 = 2;
pub const BASS_DEVICE_INIT: u32 = 4;
pub const BASS_DEVICE_LOOPBACK: u32 = 8;
pub const BASS_DEVICE_TYPE_MASK: u32 = 4278190080;
pub const BASS_DEVICE_TYPE_NETWORK: u32 = 16777216;
pub const BASS_DEVICE_TYPE_SPEAKERS: u32 = 33554432;
pub const BASS_DEVICE_TYPE_LINE: u32 = 50331648;
pub const BASS_DEVICE_TYPE_HEADPHONES: u32 = 67108864;
pub const BASS_DEVICE_TYPE_MICROPHONE: u32 = 83886080;
pub const BASS_DEVICE_TYPE_HEADSET: u32 = 100663296;
pub const BASS_DEVICE_TYPE_HANDSET: u32 = 117440512;
pub const BASS_DEVICE_TYPE_DIGITAL: u32 = 134217728;
pub const BASS_DEVICE_TYPE_SPDIF: u32 = 150994944;
pub const BASS_DEVICE_TYPE_HDMI: u32 = 167772160;
pub const BASS_DEVICE_TYPE_DISPLAYPORT: u32 = 1073741824;
pub const BASS_DEVICES_AIRPLAY: u32 = 16777216;
pub const DSCAPS_CONTINUOUSRATE: u32 = 16;
pub const DSCAPS_EMULDRIVER: u32 = 32;
pub const DSCAPS_CERTIFIED: u32 = 64;
pub const DSCAPS_SECONDARYMONO: u32 = 256;
pub const DSCAPS_SECONDARYSTEREO: u32 = 512;
pub const DSCAPS_SECONDARY8BIT: u32 = 1024;
pub const DSCAPS_SECONDARY16BIT: u32 = 2048;
pub const DSCCAPS_EMULDRIVER: u32 = 32;
pub const DSCCAPS_CERTIFIED: u32 = 64;
pub const WAVE_FORMAT_1M08: u32 = 1;
pub const WAVE_FORMAT_1S08: u32 = 2;
pub const WAVE_FORMAT_1M16: u32 = 4;
pub const WAVE_FORMAT_1S16: u32 = 8;
pub const WAVE_FORMAT_2M08: u32 = 16;
pub const WAVE_FORMAT_2S08: u32 = 32;
pub const WAVE_FORMAT_2M16: u32 = 64;
pub const WAVE_FORMAT_2S16: u32 = 128;
pub const WAVE_FORMAT_4M08: u32 = 256;
pub const WAVE_FORMAT_4S08: u32 = 512;
pub const WAVE_FORMAT_4M16: u32 = 1024;
pub const WAVE_FORMAT_4S16: u32 = 2048;
pub const BASS_SAMPLE_8BITS: u32 = 1;
pub const BASS_SAMPLE_FLOAT: u32 = 256;
pub const BASS_SAMPLE_MONO: u32 = 2;
pub const BASS_SAMPLE_LOOP: u32 = 4;
pub const BASS_SAMPLE_3D: u32 = 8;
pub const BASS_SAMPLE_SOFTWARE: u32 = 16;
pub const BASS_SAMPLE_MUTEMAX: u32 = 32;
pub const BASS_SAMPLE_VAM: u32 = 64;
pub const BASS_SAMPLE_FX: u32 = 128;
pub const BASS_SAMPLE_OVER_VOL: u32 = 65536;
pub const BASS_SAMPLE_OVER_POS: u32 = 131072;
pub const BASS_SAMPLE_OVER_DIST: u32 = 196608;
pub const BASS_STREAM_PRESCAN: u32 = 131072;
pub const BASS_STREAM_AUTOFREE: u32 = 262144;
pub const BASS_STREAM_RESTRATE: u32 = 524288;
pub const BASS_STREAM_BLOCK: u32 = 1048576;
pub const BASS_STREAM_DECODE: u32 = 2097152;
pub const BASS_STREAM_STATUS: u32 = 8388608;
pub const BASS_MP3_IGNOREDELAY: u32 = 512;
pub const BASS_MP3_SETPOS: u32 = 131072;
pub const BASS_MUSIC_FLOAT: u32 = 256;
pub const BASS_MUSIC_MONO: u32 = 2;
pub const BASS_MUSIC_LOOP: u32 = 4;
pub const BASS_MUSIC_3D: u32 = 8;
pub const BASS_MUSIC_FX: u32 = 128;
pub const BASS_MUSIC_AUTOFREE: u32 = 262144;
pub const BASS_MUSIC_DECODE: u32 = 2097152;
pub const BASS_MUSIC_PRESCAN: u32 = 131072;
pub const BASS_MUSIC_CALCLEN: u32 = 131072;
pub const BASS_MUSIC_RAMP: u32 = 512;
pub const BASS_MUSIC_RAMPS: u32 = 1024;
pub const BASS_MUSIC_SURROUND: u32 = 2048;
pub const BASS_MUSIC_SURROUND2: u32 = 4096;
pub const BASS_MUSIC_FT2PAN: u32 = 8192;
pub const BASS_MUSIC_FT2MOD: u32 = 8192;
pub const BASS_MUSIC_PT1MOD: u32 = 16384;
pub const BASS_MUSIC_NONINTER: u32 = 65536;
pub const BASS_MUSIC_SINCINTER: u32 = 8388608;
pub const BASS_MUSIC_POSRESET: u32 = 32768;
pub const BASS_MUSIC_POSRESETEX: u32 = 4194304;
pub const BASS_MUSIC_STOPBACK: u32 = 524288;
pub const BASS_MUSIC_NOSAMPLE: u32 = 1048576;
pub const BASS_SPEAKER_FRONT: u32 = 16777216;
pub const BASS_SPEAKER_REAR: u32 = 33554432;
pub const BASS_SPEAKER_CENLFE: u32 = 50331648;
pub const BASS_SPEAKER_REAR2: u32 = 67108864;
pub const BASS_SPEAKER_LEFT: u32 = 268435456;
pub const BASS_SPEAKER_RIGHT: u32 = 536870912;
pub const BASS_SPEAKER_FRONTLEFT: u32 = 285212672;
pub const BASS_SPEAKER_FRONTRIGHT: u32 = 553648128;
pub const BASS_SPEAKER_REARLEFT: u32 = 301989888;
pub const BASS_SPEAKER_REARRIGHT: u32 = 570425344;
pub const BASS_SPEAKER_CENTER: u32 = 318767104;
pub const BASS_SPEAKER_LFE: u32 = 587202560;
pub const BASS_SPEAKER_REAR2LEFT: u32 = 335544320;
pub const BASS_SPEAKER_REAR2RIGHT: u32 = 603979776;
pub const BASS_ASYNCFILE: u32 = 1073741824;
pub const BASS_UNICODE: u32 = 2147483648;
pub const BASS_RECORD_PAUSE: u32 = 32768;
pub const BASS_RECORD_ECHOCANCEL: u32 = 8192;
pub const BASS_RECORD_AGC: u32 = 16384;
pub const BASS_VAM_HARDWARE: u32 = 1;
pub const BASS_VAM_SOFTWARE: u32 = 2;
pub const BASS_VAM_TERM_TIME: u32 = 4;
pub const BASS_VAM_TERM_DIST: u32 = 8;
pub const BASS_VAM_TERM_PRIO: u32 = 16;
pub const BASS_ORIGRES_FLOAT: u32 = 65536;
pub const BASS_CTYPE_SAMPLE: u32 = 1;
pub const BASS_CTYPE_RECORD: u32 = 2;
pub const BASS_CTYPE_STREAM: u32 = 65536;
pub const BASS_CTYPE_STREAM_VORBIS: u32 = 65538;
pub const BASS_CTYPE_STREAM_OGG: u32 = 65538;
pub const BASS_CTYPE_STREAM_MP1: u32 = 65539;
pub const BASS_CTYPE_STREAM_MP2: u32 = 65540;
pub const BASS_CTYPE_STREAM_MP3: u32 = 65541;
pub const BASS_CTYPE_STREAM_AIFF: u32 = 65542;
pub const BASS_CTYPE_STREAM_CA: u32 = 65543;
pub const BASS_CTYPE_STREAM_MF: u32 = 65544;
pub const BASS_CTYPE_STREAM_AM: u32 = 65545;
pub const BASS_CTYPE_STREAM_DUMMY: u32 = 98304;
pub const BASS_CTYPE_STREAM_DEVICE: u32 = 98305;
pub const BASS_CTYPE_STREAM_WAV: u32 = 262144;
pub const BASS_CTYPE_STREAM_WAV_PCM: u32 = 327681;
pub const BASS_CTYPE_STREAM_WAV_FLOAT: u32 = 327683;
pub const BASS_CTYPE_MUSIC_MOD: u32 = 131072;
pub const BASS_CTYPE_MUSIC_MTM: u32 = 131073;
pub const BASS_CTYPE_MUSIC_S3M: u32 = 131074;
pub const BASS_CTYPE_MUSIC_XM: u32 = 131075;
pub const BASS_CTYPE_MUSIC_IT: u32 = 131076;
pub const BASS_CTYPE_MUSIC_MO3: u32 = 256;
pub const BASS_3DMODE_NORMAL: u32 = 0;
pub const BASS_3DMODE_RELATIVE: u32 = 1;
pub const BASS_3DMODE_OFF: u32 = 2;
pub const BASS_3DALG_DEFAULT: u32 = 0;
pub const BASS_3DALG_OFF: u32 = 1;
pub const BASS_3DALG_FULL: u32 = 2;
pub const BASS_3DALG_LIGHT: u32 = 3;
pub const BASS_STREAMPROC_END: u32 = 2147483648;
pub const STREAMFILE_NOBUFFER: u32 = 0;
pub const STREAMFILE_BUFFER: u32 = 1;
pub const STREAMFILE_BUFFERPUSH: u32 = 2;
pub const BASS_FILEDATA_END: u32 = 0;
pub const BASS_FILEPOS_CURRENT: u32 = 0;
pub const BASS_FILEPOS_DECODE: u32 = 0;
pub const BASS_FILEPOS_DOWNLOAD: u32 = 1;
pub const BASS_FILEPOS_END: u32 = 2;
pub const BASS_FILEPOS_START: u32 = 3;
pub const BASS_FILEPOS_CONNECTED: u32 = 4;
pub const BASS_FILEPOS_BUFFER: u32 = 5;
pub const BASS_FILEPOS_SOCKET: u32 = 6;
pub const BASS_FILEPOS_ASYNCBUF: u32 = 7;
pub const BASS_FILEPOS_SIZE: u32 = 8;
pub const BASS_FILEPOS_BUFFERING: u32 = 9;
pub const BASS_SYNC_POS: u32 = 0;
pub const BASS_SYNC_END: u32 = 2;
pub const BASS_SYNC_META: u32 = 4;
pub const BASS_SYNC_SLIDE: u32 = 5;
pub const BASS_SYNC_STALL: u32 = 6;
pub const BASS_SYNC_DOWNLOAD: u32 = 7;
pub const BASS_SYNC_FREE: u32 = 8;
pub const BASS_SYNC_SETPOS: u32 = 11;
pub const BASS_SYNC_MUSICPOS: u32 = 10;
pub const BASS_SYNC_MUSICINST: u32 = 1;
pub const BASS_SYNC_MUSICFX: u32 = 3;
pub const BASS_SYNC_OGG_CHANGE: u32 = 12;
pub const BASS_SYNC_DEV_FAIL: u32 = 14;
pub const BASS_SYNC_DEV_FORMAT: u32 = 15;
pub const BASS_SYNC_THREAD: u32 = 536870912;
pub const BASS_SYNC_MIXTIME: u32 = 1073741824;
pub const BASS_SYNC_ONETIME: u32 = 2147483648;
pub const BASS_ACTIVE_STOPPED: u32 = 0;
pub const BASS_ACTIVE_PLAYING: u32 = 1;
pub const BASS_ACTIVE_STALLED: u32 = 2;
pub const BASS_ACTIVE_PAUSED: u32 = 3;
pub const BASS_ACTIVE_PAUSED_DEVICE: u32 = 4;
pub const BASS_ATTRIB_FREQ: u32 = 1;
pub const BASS_ATTRIB_VOL: u32 = 2;
pub const BASS_ATTRIB_PAN: u32 = 3;
pub const BASS_ATTRIB_EAXMIX: u32 = 4;
pub const BASS_ATTRIB_NOBUFFER: u32 = 5;
pub const BASS_ATTRIB_VBR: u32 = 6;
pub const BASS_ATTRIB_CPU: u32 = 7;
pub const BASS_ATTRIB_SRC: u32 = 8;
pub const BASS_ATTRIB_NET_RESUME: u32 = 9;
pub const BASS_ATTRIB_SCANINFO: u32 = 10;
pub const BASS_ATTRIB_NORAMP: u32 = 11;
pub const BASS_ATTRIB_BITRATE: u32 = 12;
pub const BASS_ATTRIB_BUFFER: u32 = 13;
pub const BASS_ATTRIB_GRANULE: u32 = 14;
pub const BASS_ATTRIB_MUSIC_AMPLIFY: u32 = 256;
pub const BASS_ATTRIB_MUSIC_PANSEP: u32 = 257;
pub const BASS_ATTRIB_MUSIC_PSCALER: u32 = 258;
pub const BASS_ATTRIB_MUSIC_BPM: u32 = 259;
pub const BASS_ATTRIB_MUSIC_SPEED: u32 = 260;
pub const BASS_ATTRIB_MUSIC_VOL_GLOBAL: u32 = 261;
pub const BASS_ATTRIB_MUSIC_ACTIVE: u32 = 262;
pub const BASS_ATTRIB_MUSIC_VOL_CHAN: u32 = 512;
pub const BASS_ATTRIB_MUSIC_VOL_INST: u32 = 768;
pub const BASS_SLIDE_LOG: u32 = 16777216;
pub const BASS_DATA_AVAILABLE: u32 = 0;
pub const BASS_DATA_FIXED: u32 = 536870912;
pub const BASS_DATA_FLOAT: u32 = 1073741824;
pub const BASS_DATA_FFT256: u32 = 2147483648;
pub const BASS_DATA_FFT512: u32 = 2147483649;
pub const BASS_DATA_FFT1024: u32 = 2147483650;
pub const BASS_DATA_FFT2048: u32 = 2147483651;
pub const BASS_DATA_FFT4096: u32 = 2147483652;
pub const BASS_DATA_FFT8192: u32 = 2147483653;
pub const BASS_DATA_FFT16384: u32 = 2147483654;
pub const BASS_DATA_FFT32768: u32 = 2147483655;
pub const BASS_DATA_FFT_INDIVIDUAL: u32 = 16;
pub const BASS_DATA_FFT_NOWINDOW: u32 = 32;
pub const BASS_DATA_FFT_REMOVEDC: u32 = 64;
pub const BASS_DATA_FFT_COMPLEX: u32 = 128;
pub const BASS_DATA_FFT_NYQUIST: u32 = 256;
pub const BASS_LEVEL_MONO: u32 = 1;
pub const BASS_LEVEL_STEREO: u32 = 2;
pub const BASS_LEVEL_RMS: u32 = 4;
pub const BASS_LEVEL_VOLPAN: u32 = 8;
pub const BASS_TAG_ID3: u32 = 0;
pub const BASS_TAG_ID3V2: u32 = 1;
pub const BASS_TAG_OGG: u32 = 2;
pub const BASS_TAG_HTTP: u32 = 3;
pub const BASS_TAG_ICY: u32 = 4;
pub const BASS_TAG_META: u32 = 5;
pub const BASS_TAG_APE: u32 = 6;
pub const BASS_TAG_MP4: u32 = 7;
pub const BASS_TAG_WMA: u32 = 8;
pub const BASS_TAG_VENDOR: u32 = 9;
pub const BASS_TAG_LYRICS3: u32 = 10;
pub const BASS_TAG_CA_CODEC: u32 = 11;
pub const BASS_TAG_MF: u32 = 13;
pub const BASS_TAG_WAVEFORMAT: u32 = 14;
pub const BASS_TAG_AM_MIME: u32 = 15;
pub const BASS_TAG_AM_NAME: u32 = 16;
pub const BASS_TAG_RIFF_INFO: u32 = 256;
pub const BASS_TAG_RIFF_BEXT: u32 = 257;
pub const BASS_TAG_RIFF_CART: u32 = 258;
pub const BASS_TAG_RIFF_DISP: u32 = 259;
pub const BASS_TAG_RIFF_CUE: u32 = 260;
pub const BASS_TAG_RIFF_SMPL: u32 = 261;
pub const BASS_TAG_APE_BINARY: u32 = 4096;
pub const BASS_TAG_MUSIC_NAME: u32 = 65536;
pub const BASS_TAG_MUSIC_MESSAGE: u32 = 65537;
pub const BASS_TAG_MUSIC_ORDERS: u32 = 65538;
pub const BASS_TAG_MUSIC_AUTH: u32 = 65539;
pub const BASS_TAG_MUSIC_INST: u32 = 65792;
pub const BASS_TAG_MUSIC_SAMPLE: u32 = 66304;
pub const BASS_POS_BYTE: u32 = 0;
pub const BASS_POS_MUSIC_ORDER: u32 = 1;
pub const BASS_POS_OGG: u32 = 3;
pub const BASS_POS_RESET: u32 = 33554432;
pub const BASS_POS_RELATIVE: u32 = 67108864;
pub const BASS_POS_INEXACT: u32 = 134217728;
pub const BASS_POS_DECODE: u32 = 268435456;
pub const BASS_POS_DECODETO: u32 = 536870912;
pub const BASS_POS_SCAN: u32 = 1073741824;
pub const BASS_NODEVICE: u32 = 131072;
pub const BASS_INPUT_OFF: u32 = 65536;
pub const BASS_INPUT_ON: u32 = 131072;
pub const BASS_INPUT_TYPE_MASK: u32 = 4278190080;
pub const BASS_INPUT_TYPE_UNDEF: u32 = 0;
pub const BASS_INPUT_TYPE_DIGITAL: u32 = 16777216;
pub const BASS_INPUT_TYPE_LINE: u32 = 33554432;
pub const BASS_INPUT_TYPE_MIC: u32 = 50331648;
pub const BASS_INPUT_TYPE_SYNTH: u32 = 67108864;
pub const BASS_INPUT_TYPE_CD: u32 = 83886080;
pub const BASS_INPUT_TYPE_PHONE: u32 = 100663296;
pub const BASS_INPUT_TYPE_SPEAKER: u32 = 117440512;
pub const BASS_INPUT_TYPE_WAVE: u32 = 134217728;
pub const BASS_INPUT_TYPE_AUX: u32 = 150994944;
pub const BASS_INPUT_TYPE_ANALOG: u32 = 167772160;
pub const BASS_FX_DX8_CHORUS: u32 = 0;
pub const BASS_FX_DX8_COMPRESSOR: u32 = 1;
pub const BASS_FX_DX8_DISTORTION: u32 = 2;
pub const BASS_FX_DX8_ECHO: u32 = 3;
pub const BASS_FX_DX8_FLANGER: u32 = 4;
pub const BASS_FX_DX8_GARGLE: u32 = 5;
pub const BASS_FX_DX8_I3DL2REVERB: u32 = 6;
pub const BASS_FX_DX8_PARAMEQ: u32 = 7;
pub const BASS_FX_DX8_REVERB: u32 = 8;
pub const BASS_FX_VOLUME: u32 = 9;
pub const BASS_DX8_PHASE_NEG_180: u32 = 0;
pub const BASS_DX8_PHASE_NEG_90: u32 = 1;
pub const BASS_DX8_PHASE_ZERO: u32 = 2;
pub const BASS_DX8_PHASE_90: u32 = 3;
pub const BASS_DX8_PHASE_180: u32 = 4;
pub const BASS_IOSNOTIFY_INTERRUPT: u32 = 1;
pub const BASS_IOSNOTIFY_INTERRUPT_END: u32 = 2;
pub const BASS_CTYPE_STREAM_TEMPO: u32 = 127488;
pub const BASS_CTYPE_STREAM_REVERSE: u32 = 127489;
pub const BASS_FX_FREESOURCE: u32 = 65536;
pub const BASS_BFX_CHANALL: i32 = -1;
pub const BASS_BFX_CHANNONE: u32 = 0;
pub const BASS_BFX_CHAN1: u32 = 1;
pub const BASS_BFX_CHAN2: u32 = 2;
pub const BASS_BFX_CHAN3: u32 = 4;
pub const BASS_BFX_CHAN4: u32 = 8;
pub const BASS_BFX_CHAN5: u32 = 16;
pub const BASS_BFX_CHAN6: u32 = 32;
pub const BASS_BFX_CHAN7: u32 = 64;
pub const BASS_BFX_CHAN8: u32 = 128;
pub const BASS_BFX_FREEVERB_MODE_FREEZE: u32 = 1;
pub const BASS_FX_TEMPO_ALGO_LINEAR: u32 = 512;
pub const BASS_FX_TEMPO_ALGO_CUBIC: u32 = 1024;
pub const BASS_FX_TEMPO_ALGO_SHANNON: u32 = 2048;
pub const BASS_ATTRIB_REVERSE_DIR: u32 = 69632;
pub const BASS_FX_RVS_REVERSE: i32 = -1;
pub const BASS_FX_RVS_FORWARD: u32 = 1;
pub const BASS_FX_BPM_BKGRND: u32 = 1;
pub const BASS_FX_BPM_MULT2: u32 = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type BYTE = u8;
pub type WORD = u16;
pub type DWORD = u32;
pub type QWORD = u64;
pub type BOOL = ::std::os::raw::c_int;
pub type HMUSIC = DWORD;
pub type HSAMPLE = DWORD;
pub type HCHANNEL = DWORD;
pub type HSTREAM = DWORD;
pub type HRECORD = DWORD;
pub type HSYNC = DWORD;
pub type HDSP = DWORD;
pub type HFX = DWORD;
pub type HPLUGIN = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DEVICEINFO {
    pub name: *const ::std::os::raw::c_char,
    pub driver: *const ::std::os::raw::c_char,
    pub flags: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DEVICEINFO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DEVICEINFO>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_DEVICEINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DEVICEINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_DEVICEINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DEVICEINFO>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DEVICEINFO), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DEVICEINFO>())).driver as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_DEVICEINFO), "::", stringify!(driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DEVICEINFO>())).flags as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_DEVICEINFO), "::", stringify!(flags))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_INFO {
    pub flags: DWORD,
    pub hwsize: DWORD,
    pub hwfree: DWORD,
    pub freesam: DWORD,
    pub free3d: DWORD,
    pub minrate: DWORD,
    pub maxrate: DWORD,
    pub eax: BOOL,
    pub minbuf: DWORD,
    pub dsver: DWORD,
    pub latency: DWORD,
    pub initflags: DWORD,
    pub speakers: DWORD,
    pub freq: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(BASS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).hwsize as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(hwsize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).hwfree as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(hwfree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).freesam as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(freesam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).free3d as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(free3d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).minrate as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(minrate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).maxrate as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(maxrate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).eax as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(eax))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).minbuf as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(minbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).dsver as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(dsver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).latency as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(latency))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).initflags as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(initflags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).speakers as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(speakers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_INFO>())).freq as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(BASS_INFO), "::", stringify!(freq))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_RECORDINFO {
    pub flags: DWORD,
    pub formats: DWORD,
    pub inputs: DWORD,
    pub singlein: BOOL,
    pub freq: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_RECORDINFO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_RECORDINFO>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_RECORDINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_RECORDINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_RECORDINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_RECORDINFO>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_RECORDINFO), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_RECORDINFO>())).formats as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_RECORDINFO), "::", stringify!(formats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_RECORDINFO>())).inputs as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_RECORDINFO), "::", stringify!(inputs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_RECORDINFO>())).singlein as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_RECORDINFO), "::", stringify!(singlein))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_RECORDINFO>())).freq as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_RECORDINFO), "::", stringify!(freq))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_SAMPLE {
    pub freq: DWORD,
    pub volume: f32,
    pub pan: f32,
    pub flags: DWORD,
    pub length: DWORD,
    pub max: DWORD,
    pub origres: DWORD,
    pub chans: DWORD,
    pub mingap: DWORD,
    pub mode3d: DWORD,
    pub mindist: f32,
    pub maxdist: f32,
    pub iangle: DWORD,
    pub oangle: DWORD,
    pub outvol: f32,
    pub vam: DWORD,
    pub priority: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_SAMPLE() {
    assert_eq!(
        ::std::mem::size_of::<BASS_SAMPLE>(),
        68usize,
        concat!("Size of: ", stringify!(BASS_SAMPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_SAMPLE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_SAMPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).freq as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(freq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).volume as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(volume))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).pan as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(pan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).flags as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).length as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).max as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(max))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).origres as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(origres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).chans as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(chans))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).mingap as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(mingap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).mode3d as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(mode3d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).mindist as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(mindist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).maxdist as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(maxdist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).iangle as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(iangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).oangle as *const _ as usize },
        52usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(oangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).outvol as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(outvol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).vam as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(vam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_SAMPLE>())).priority as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(BASS_SAMPLE), "::", stringify!(priority))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_CHANNELINFO {
    pub freq: DWORD,
    pub chans: DWORD,
    pub flags: DWORD,
    pub ctype: DWORD,
    pub origres: DWORD,
    pub plugin: HPLUGIN,
    pub sample: HSAMPLE,
    pub filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BASS_CHANNELINFO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_CHANNELINFO>(),
        40usize,
        concat!("Size of: ", stringify!(BASS_CHANNELINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_CHANNELINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_CHANNELINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).freq as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(freq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).chans as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(chans))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).flags as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).ctype as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(ctype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).origres as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(origres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).plugin as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(plugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).sample as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(sample))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_CHANNELINFO>())).filename as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(BASS_CHANNELINFO), "::", stringify!(filename))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_PLUGINFORM {
    pub ctype: DWORD,
    pub name: *const ::std::os::raw::c_char,
    pub exts: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BASS_PLUGINFORM() {
    assert_eq!(
        ::std::mem::size_of::<BASS_PLUGINFORM>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_PLUGINFORM))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_PLUGINFORM>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_PLUGINFORM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGINFORM>())).ctype as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGINFORM), "::", stringify!(ctype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGINFORM>())).name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGINFORM), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGINFORM>())).exts as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGINFORM), "::", stringify!(exts))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_PLUGININFO {
    pub version: DWORD,
    pub formatc: DWORD,
    pub formats: *const BASS_PLUGINFORM,
}
#[test]
fn bindgen_test_layout_BASS_PLUGININFO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_PLUGININFO>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_PLUGININFO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_PLUGININFO>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_PLUGININFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGININFO>())).version as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGININFO), "::", stringify!(version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGININFO>())).formatc as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGININFO), "::", stringify!(formatc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_PLUGININFO>())).formats as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_PLUGININFO), "::", stringify!(formats))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_3DVECTOR {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_BASS_3DVECTOR() {
    assert_eq!(
        ::std::mem::size_of::<BASS_3DVECTOR>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_3DVECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_3DVECTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_3DVECTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_3DVECTOR>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_3DVECTOR), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_3DVECTOR>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_3DVECTOR), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_3DVECTOR>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_3DVECTOR), "::", stringify!(z))
    );
}
pub const EAX_ENVIRONMENT_GENERIC: _bindgen_ty_1 = 0;
pub const EAX_ENVIRONMENT_PADDEDCELL: _bindgen_ty_1 = 1;
pub const EAX_ENVIRONMENT_ROOM: _bindgen_ty_1 = 2;
pub const EAX_ENVIRONMENT_BATHROOM: _bindgen_ty_1 = 3;
pub const EAX_ENVIRONMENT_LIVINGROOM: _bindgen_ty_1 = 4;
pub const EAX_ENVIRONMENT_STONEROOM: _bindgen_ty_1 = 5;
pub const EAX_ENVIRONMENT_AUDITORIUM: _bindgen_ty_1 = 6;
pub const EAX_ENVIRONMENT_CONCERTHALL: _bindgen_ty_1 = 7;
pub const EAX_ENVIRONMENT_CAVE: _bindgen_ty_1 = 8;
pub const EAX_ENVIRONMENT_ARENA: _bindgen_ty_1 = 9;
pub const EAX_ENVIRONMENT_HANGAR: _bindgen_ty_1 = 10;
pub const EAX_ENVIRONMENT_CARPETEDHALLWAY: _bindgen_ty_1 = 11;
pub const EAX_ENVIRONMENT_HALLWAY: _bindgen_ty_1 = 12;
pub const EAX_ENVIRONMENT_STONECORRIDOR: _bindgen_ty_1 = 13;
pub const EAX_ENVIRONMENT_ALLEY: _bindgen_ty_1 = 14;
pub const EAX_ENVIRONMENT_FOREST: _bindgen_ty_1 = 15;
pub const EAX_ENVIRONMENT_CITY: _bindgen_ty_1 = 16;
pub const EAX_ENVIRONMENT_MOUNTAINS: _bindgen_ty_1 = 17;
pub const EAX_ENVIRONMENT_QUARRY: _bindgen_ty_1 = 18;
pub const EAX_ENVIRONMENT_PLAIN: _bindgen_ty_1 = 19;
pub const EAX_ENVIRONMENT_PARKINGLOT: _bindgen_ty_1 = 20;
pub const EAX_ENVIRONMENT_SEWERPIPE: _bindgen_ty_1 = 21;
pub const EAX_ENVIRONMENT_UNDERWATER: _bindgen_ty_1 = 22;
pub const EAX_ENVIRONMENT_DRUGGED: _bindgen_ty_1 = 23;
pub const EAX_ENVIRONMENT_DIZZY: _bindgen_ty_1 = 24;
pub const EAX_ENVIRONMENT_PSYCHOTIC: _bindgen_ty_1 = 25;
pub const EAX_ENVIRONMENT_COUNT: _bindgen_ty_1 = 26;
pub type _bindgen_ty_1 = u32;
pub type STREAMPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HSTREAM,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> DWORD,
>;
pub type FILECLOSEPROC = ::std::option::Option<unsafe extern "C" fn(user: *mut ::std::os::raw::c_void)>;
pub type FILELENPROC = ::std::option::Option<unsafe extern "C" fn(user: *mut ::std::os::raw::c_void) -> QWORD>;
pub type FILEREADPROC = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_void, length: DWORD, user: *mut ::std::os::raw::c_void) -> DWORD,
>;
pub type FILESEEKPROC = ::std::option::Option<unsafe extern "C" fn(offset: QWORD, user: *mut ::std::os::raw::c_void) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_FILEPROCS {
    pub close: FILECLOSEPROC,
    pub length: FILELENPROC,
    pub read: FILEREADPROC,
    pub seek: FILESEEKPROC,
}
#[test]
fn bindgen_test_layout_BASS_FILEPROCS() {
    assert_eq!(
        ::std::mem::size_of::<BASS_FILEPROCS>(),
        32usize,
        concat!("Size of: ", stringify!(BASS_FILEPROCS))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_FILEPROCS>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_FILEPROCS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FILEPROCS>())).close as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_FILEPROCS), "::", stringify!(close))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FILEPROCS>())).length as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_FILEPROCS), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FILEPROCS>())).read as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_FILEPROCS), "::", stringify!(read))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FILEPROCS>())).seek as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_FILEPROCS), "::", stringify!(seek))
    );
}
pub type DOWNLOADPROC = ::std::option::Option<
    unsafe extern "C" fn(buffer: *const ::std::os::raw::c_void, length: DWORD, user: *mut ::std::os::raw::c_void),
>;
pub type SYNCPROC =
    ::std::option::Option<unsafe extern "C" fn(handle: HSYNC, channel: DWORD, data: DWORD, user: *mut ::std::os::raw::c_void)>;
pub type DSPPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HDSP,
        channel: DWORD,
        buffer: *mut ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ),
>;
pub type RECORDPROC = ::std::option::Option<
    unsafe extern "C" fn(
        handle: HRECORD,
        buffer: *const ::std::os::raw::c_void,
        length: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_ID3 {
    pub id: [::std::os::raw::c_char; 3usize],
    pub title: [::std::os::raw::c_char; 30usize],
    pub artist: [::std::os::raw::c_char; 30usize],
    pub album: [::std::os::raw::c_char; 30usize],
    pub year: [::std::os::raw::c_char; 4usize],
    pub comment: [::std::os::raw::c_char; 30usize],
    pub genre: BYTE,
}
#[test]
fn bindgen_test_layout_TAG_ID3() {
    assert_eq!(
        ::std::mem::size_of::<TAG_ID3>(),
        128usize,
        concat!("Size of: ", stringify!(TAG_ID3))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_ID3>(),
        1usize,
        concat!("Alignment of ", stringify!(TAG_ID3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).title as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(title))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).artist as *const _ as usize },
        33usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(artist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).album as *const _ as usize },
        63usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(album))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).year as *const _ as usize },
        93usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(year))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).comment as *const _ as usize },
        97usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(comment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_ID3>())).genre as *const _ as usize },
        127usize,
        concat!("Offset of field: ", stringify!(TAG_ID3), "::", stringify!(genre))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_APE_BINARY {
    pub key: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_void,
    pub length: DWORD,
}
#[test]
fn bindgen_test_layout_TAG_APE_BINARY() {
    assert_eq!(
        ::std::mem::size_of::<TAG_APE_BINARY>(),
        24usize,
        concat!("Size of: ", stringify!(TAG_APE_BINARY))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_APE_BINARY>(),
        8usize,
        concat!("Alignment of ", stringify!(TAG_APE_BINARY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_APE_BINARY>())).key as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_APE_BINARY), "::", stringify!(key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_APE_BINARY>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(TAG_APE_BINARY), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_APE_BINARY>())).length as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(TAG_APE_BINARY), "::", stringify!(length))
    );
}
#[repr(C, packed)]
pub struct TAG_BEXT {
    pub Description: [::std::os::raw::c_char; 256usize],
    pub Originator: [::std::os::raw::c_char; 32usize],
    pub OriginatorReference: [::std::os::raw::c_char; 32usize],
    pub OriginationDate: [::std::os::raw::c_char; 10usize],
    pub OriginationTime: [::std::os::raw::c_char; 8usize],
    pub TimeReference: QWORD,
    pub Version: WORD,
    pub UMID: [BYTE; 64usize],
    pub Reserved: [BYTE; 190usize],
    pub CodingHistory: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_TAG_BEXT() {
    assert_eq!(
        ::std::mem::size_of::<TAG_BEXT>(),
        602usize,
        concat!("Size of: ", stringify!(TAG_BEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_BEXT>(),
        1usize,
        concat!("Alignment of ", stringify!(TAG_BEXT))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_CART_TIMER {
    pub dwUsage: DWORD,
    pub dwValue: DWORD,
}
#[test]
fn bindgen_test_layout_TAG_CART_TIMER() {
    assert_eq!(
        ::std::mem::size_of::<TAG_CART_TIMER>(),
        8usize,
        concat!("Size of: ", stringify!(TAG_CART_TIMER))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_CART_TIMER>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_CART_TIMER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CART_TIMER>())).dwUsage as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_CART_TIMER), "::", stringify!(dwUsage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CART_TIMER>())).dwValue as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(TAG_CART_TIMER), "::", stringify!(dwValue))
    );
}
#[repr(C)]
pub struct TAG_CART {
    pub Version: [::std::os::raw::c_char; 4usize],
    pub Title: [::std::os::raw::c_char; 64usize],
    pub Artist: [::std::os::raw::c_char; 64usize],
    pub CutID: [::std::os::raw::c_char; 64usize],
    pub ClientID: [::std::os::raw::c_char; 64usize],
    pub Category: [::std::os::raw::c_char; 64usize],
    pub Classification: [::std::os::raw::c_char; 64usize],
    pub OutCue: [::std::os::raw::c_char; 64usize],
    pub StartDate: [::std::os::raw::c_char; 10usize],
    pub StartTime: [::std::os::raw::c_char; 8usize],
    pub EndDate: [::std::os::raw::c_char; 10usize],
    pub EndTime: [::std::os::raw::c_char; 8usize],
    pub ProducerAppID: [::std::os::raw::c_char; 64usize],
    pub ProducerAppVersion: [::std::os::raw::c_char; 64usize],
    pub UserDef: [::std::os::raw::c_char; 64usize],
    pub dwLevelReference: DWORD,
    pub PostTimer: [TAG_CART_TIMER; 8usize],
    pub Reserved: [::std::os::raw::c_char; 276usize],
    pub URL: [::std::os::raw::c_char; 1024usize],
    pub TagText: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_TAG_CART() {
    assert_eq!(
        ::std::mem::size_of::<TAG_CART>(),
        2048usize,
        concat!("Size of: ", stringify!(TAG_CART))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_CART>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_CART))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_CUE_POINT {
    pub dwName: DWORD,
    pub dwPosition: DWORD,
    pub fccChunk: DWORD,
    pub dwChunkStart: DWORD,
    pub dwBlockStart: DWORD,
    pub dwSampleOffset: DWORD,
}
#[test]
fn bindgen_test_layout_TAG_CUE_POINT() {
    assert_eq!(
        ::std::mem::size_of::<TAG_CUE_POINT>(),
        24usize,
        concat!("Size of: ", stringify!(TAG_CUE_POINT))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_CUE_POINT>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_CUE_POINT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).dwName as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_CUE_POINT), "::", stringify!(dwName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).dwPosition as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(TAG_CUE_POINT), "::", stringify!(dwPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).fccChunk as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(TAG_CUE_POINT), "::", stringify!(fccChunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).dwChunkStart as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(TAG_CUE_POINT), "::", stringify!(dwChunkStart))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).dwBlockStart as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(TAG_CUE_POINT), "::", stringify!(dwBlockStart))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CUE_POINT>())).dwSampleOffset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TAG_CUE_POINT),
            "::",
            stringify!(dwSampleOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct TAG_CUE {
    pub dwCuePoints: DWORD,
    pub CuePoints: __IncompleteArrayField<TAG_CUE_POINT>,
}
#[test]
fn bindgen_test_layout_TAG_CUE() {
    assert_eq!(
        ::std::mem::size_of::<TAG_CUE>(),
        4usize,
        concat!("Size of: ", stringify!(TAG_CUE))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_CUE>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_CUE))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_SMPL_LOOP {
    pub dwIdentifier: DWORD,
    pub dwType: DWORD,
    pub dwStart: DWORD,
    pub dwEnd: DWORD,
    pub dwFraction: DWORD,
    pub dwPlayCount: DWORD,
}
#[test]
fn bindgen_test_layout_TAG_SMPL_LOOP() {
    assert_eq!(
        ::std::mem::size_of::<TAG_SMPL_LOOP>(),
        24usize,
        concat!("Size of: ", stringify!(TAG_SMPL_LOOP))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_SMPL_LOOP>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_SMPL_LOOP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwIdentifier as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwIdentifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwType as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwStart as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwStart))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwEnd as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwEnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwFraction as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwFraction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_SMPL_LOOP>())).dwPlayCount as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(TAG_SMPL_LOOP), "::", stringify!(dwPlayCount))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct TAG_SMPL {
    pub dwManufacturer: DWORD,
    pub dwProduct: DWORD,
    pub dwSamplePeriod: DWORD,
    pub dwMIDIUnityNote: DWORD,
    pub dwMIDIPitchFraction: DWORD,
    pub dwSMPTEFormat: DWORD,
    pub dwSMPTEOffset: DWORD,
    pub cSampleLoops: DWORD,
    pub cbSamplerData: DWORD,
    pub SampleLoops: __IncompleteArrayField<TAG_SMPL_LOOP>,
}
#[test]
fn bindgen_test_layout_TAG_SMPL() {
    assert_eq!(
        ::std::mem::size_of::<TAG_SMPL>(),
        36usize,
        concat!("Size of: ", stringify!(TAG_SMPL))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_SMPL>(),
        4usize,
        concat!("Alignment of ", stringify!(TAG_SMPL))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TAG_CA_CODEC {
    pub ftype: DWORD,
    pub atype: DWORD,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TAG_CA_CODEC() {
    assert_eq!(
        ::std::mem::size_of::<TAG_CA_CODEC>(),
        16usize,
        concat!("Size of: ", stringify!(TAG_CA_CODEC))
    );
    assert_eq!(
        ::std::mem::align_of::<TAG_CA_CODEC>(),
        8usize,
        concat!("Alignment of ", stringify!(TAG_CA_CODEC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CA_CODEC>())).ftype as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TAG_CA_CODEC), "::", stringify!(ftype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CA_CODEC>())).atype as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(TAG_CA_CODEC), "::", stringify!(atype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TAG_CA_CODEC>())).name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(TAG_CA_CODEC), "::", stringify!(name))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tWAVEFORMATEX {
    pub wFormatTag: WORD,
    pub nChannels: WORD,
    pub nSamplesPerSec: DWORD,
    pub nAvgBytesPerSec: DWORD,
    pub nBlockAlign: WORD,
    pub wBitsPerSample: WORD,
    pub cbSize: WORD,
}
#[test]
fn bindgen_test_layout_tWAVEFORMATEX() {
    assert_eq!(
        ::std::mem::size_of::<tWAVEFORMATEX>(),
        18usize,
        concat!("Size of: ", stringify!(tWAVEFORMATEX))
    );
    assert_eq!(
        ::std::mem::align_of::<tWAVEFORMATEX>(),
        1usize,
        concat!("Alignment of ", stringify!(tWAVEFORMATEX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).wFormatTag as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(tWAVEFORMATEX), "::", stringify!(wFormatTag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).nChannels as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(tWAVEFORMATEX), "::", stringify!(nChannels))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).nSamplesPerSec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nSamplesPerSec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).nAvgBytesPerSec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(nAvgBytesPerSec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).nBlockAlign as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(tWAVEFORMATEX), "::", stringify!(nBlockAlign))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).wBitsPerSample as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tWAVEFORMATEX),
            "::",
            stringify!(wBitsPerSample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tWAVEFORMATEX>())).cbSize as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(tWAVEFORMATEX), "::", stringify!(cbSize))
    );
}
pub type WAVEFORMATEX = tWAVEFORMATEX;
pub type PWAVEFORMATEX = *mut tWAVEFORMATEX;
pub type LPWAVEFORMATEX = *mut tWAVEFORMATEX;
pub type LPCWAVEFORMATEX = *const WAVEFORMATEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_CHORUS {
    pub fWetDryMix: f32,
    pub fDepth: f32,
    pub fFeedback: f32,
    pub fFrequency: f32,
    pub lWaveform: DWORD,
    pub fDelay: f32,
    pub lPhase: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_CHORUS() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_CHORUS>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_DX8_CHORUS))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_CHORUS>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_CHORUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).fWetDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(fWetDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).fDepth as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(fDepth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).fFrequency as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(fFrequency))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).lWaveform as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(lWaveform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).fDelay as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_CHORUS>())).lPhase as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_CHORUS), "::", stringify!(lPhase))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_COMPRESSOR {
    pub fGain: f32,
    pub fAttack: f32,
    pub fRelease: f32,
    pub fThreshold: f32,
    pub fRatio: f32,
    pub fPredelay: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_COMPRESSOR() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_COMPRESSOR>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_DX8_COMPRESSOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_COMPRESSOR>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_COMPRESSOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fGain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_COMPRESSOR), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fAttack as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fAttack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fRelease as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fRelease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fThreshold as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fRatio as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_COMPRESSOR), "::", stringify!(fRatio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_COMPRESSOR>())).fPredelay as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_COMPRESSOR),
            "::",
            stringify!(fPredelay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_DISTORTION {
    pub fGain: f32,
    pub fEdge: f32,
    pub fPostEQCenterFrequency: f32,
    pub fPostEQBandwidth: f32,
    pub fPreLowpassCutoff: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_DISTORTION() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_DISTORTION>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_DX8_DISTORTION))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_DISTORTION>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_DISTORTION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_DISTORTION>())).fGain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_DISTORTION), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_DISTORTION>())).fEdge as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_DISTORTION), "::", stringify!(fEdge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_DISTORTION>())).fPostEQCenterFrequency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPostEQCenterFrequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_DISTORTION>())).fPostEQBandwidth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPostEQBandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_DISTORTION>())).fPreLowpassCutoff as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_DISTORTION),
            "::",
            stringify!(fPreLowpassCutoff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_ECHO {
    pub fWetDryMix: f32,
    pub fFeedback: f32,
    pub fLeftDelay: f32,
    pub fRightDelay: f32,
    pub lPanDelay: BOOL,
}
#[test]
fn bindgen_test_layout_BASS_DX8_ECHO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_ECHO>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_DX8_ECHO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_ECHO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_ECHO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_ECHO>())).fWetDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_ECHO), "::", stringify!(fWetDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_ECHO>())).fFeedback as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_ECHO), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_ECHO>())).fLeftDelay as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_ECHO), "::", stringify!(fLeftDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_ECHO>())).fRightDelay as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_ECHO), "::", stringify!(fRightDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_ECHO>())).lPanDelay as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_ECHO), "::", stringify!(lPanDelay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_FLANGER {
    pub fWetDryMix: f32,
    pub fDepth: f32,
    pub fFeedback: f32,
    pub fFrequency: f32,
    pub lWaveform: DWORD,
    pub fDelay: f32,
    pub lPhase: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_FLANGER() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_FLANGER>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_DX8_FLANGER))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_FLANGER>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_FLANGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).fWetDryMix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fWetDryMix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).fDepth as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_FLANGER), "::", stringify!(fDepth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_FLANGER), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).fFrequency as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_FLANGER),
            "::",
            stringify!(fFrequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).lWaveform as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_FLANGER), "::", stringify!(lWaveform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).fDelay as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_FLANGER), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_FLANGER>())).lPhase as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_FLANGER), "::", stringify!(lPhase))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_GARGLE {
    pub dwRateHz: DWORD,
    pub dwWaveShape: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_DX8_GARGLE() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_GARGLE>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_DX8_GARGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_GARGLE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_GARGLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_GARGLE>())).dwRateHz as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_GARGLE), "::", stringify!(dwRateHz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_GARGLE>())).dwWaveShape as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_GARGLE),
            "::",
            stringify!(dwWaveShape)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_I3DL2REVERB {
    pub lRoom: ::std::os::raw::c_int,
    pub lRoomHF: ::std::os::raw::c_int,
    pub flRoomRolloffFactor: f32,
    pub flDecayTime: f32,
    pub flDecayHFRatio: f32,
    pub lReflections: ::std::os::raw::c_int,
    pub flReflectionsDelay: f32,
    pub lReverb: ::std::os::raw::c_int,
    pub flReverbDelay: f32,
    pub flDiffusion: f32,
    pub flDensity: f32,
    pub flHFReference: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_I3DL2REVERB() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_I3DL2REVERB>(),
        48usize,
        concat!("Size of: ", stringify!(BASS_DX8_I3DL2REVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_I3DL2REVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_I3DL2REVERB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).lRoom as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_I3DL2REVERB), "::", stringify!(lRoom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).lRoomHF as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lRoomHF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flRoomRolloffFactor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flRoomRolloffFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flDecayTime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDecayTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flDecayHFRatio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDecayHFRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).lReflections as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lReflections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flReflectionsDelay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flReflectionsDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).lReverb as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(lReverb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flReverbDelay as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flReverbDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flDiffusion as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDiffusion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flDensity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flDensity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_I3DL2REVERB>())).flHFReference as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_I3DL2REVERB),
            "::",
            stringify!(flHFReference)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_PARAMEQ {
    pub fCenter: f32,
    pub fBandwidth: f32,
    pub fGain: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_PARAMEQ() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_PARAMEQ>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_DX8_PARAMEQ))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_PARAMEQ>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_PARAMEQ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_PARAMEQ>())).fCenter as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_PARAMEQ), "::", stringify!(fCenter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_PARAMEQ>())).fBandwidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_PARAMEQ),
            "::",
            stringify!(fBandwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_PARAMEQ>())).fGain as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_PARAMEQ), "::", stringify!(fGain))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_DX8_REVERB {
    pub fInGain: f32,
    pub fReverbMix: f32,
    pub fReverbTime: f32,
    pub fHighFreqRTRatio: f32,
}
#[test]
fn bindgen_test_layout_BASS_DX8_REVERB() {
    assert_eq!(
        ::std::mem::size_of::<BASS_DX8_REVERB>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_DX8_REVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_DX8_REVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_DX8_REVERB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_REVERB>())).fInGain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_REVERB), "::", stringify!(fInGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_REVERB>())).fReverbMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_DX8_REVERB), "::", stringify!(fReverbMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_REVERB>())).fReverbTime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fReverbTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_DX8_REVERB>())).fHighFreqRTRatio as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_DX8_REVERB),
            "::",
            stringify!(fHighFreqRTRatio)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_FX_VOLUME_PARAM {
    pub fTarget: f32,
    pub fCurrent: f32,
    pub fTime: f32,
    pub lCurve: DWORD,
}
#[test]
fn bindgen_test_layout_BASS_FX_VOLUME_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<BASS_FX_VOLUME_PARAM>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_FX_VOLUME_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_FX_VOLUME_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_FX_VOLUME_PARAM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FX_VOLUME_PARAM>())).fTarget as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(fTarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FX_VOLUME_PARAM>())).fCurrent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(fCurrent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FX_VOLUME_PARAM>())).fTime as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_FX_VOLUME_PARAM), "::", stringify!(fTime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_FX_VOLUME_PARAM>())).lCurve as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_FX_VOLUME_PARAM),
            "::",
            stringify!(lCurve)
        )
    );
}
pub type IOSNOTIFYPROC = ::std::option::Option<unsafe extern "C" fn(status: DWORD)>;
extern "C" {
    pub fn BASS_SetConfig(option: DWORD, value: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_GetConfig(option: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_SetConfigPtr(option: DWORD, value: *const ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_GetConfigPtr(option: DWORD) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BASS_GetVersion() -> DWORD;
}
extern "C" {
    pub fn BASS_ErrorGetCode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BASS_GetDeviceInfo(device: DWORD, info: *mut BASS_DEVICEINFO) -> BOOL;
}
extern "C" {
    pub fn BASS_Init(
        device: ::std::os::raw::c_int,
        freq: DWORD,
        flags: DWORD,
        win: *mut ::std::os::raw::c_void,
        dsguid: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_SetDevice(device: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_GetDevice() -> DWORD;
}
extern "C" {
    pub fn BASS_Free() -> BOOL;
}
extern "C" {
    pub fn BASS_GetInfo(info: *mut BASS_INFO) -> BOOL;
}
extern "C" {
    pub fn BASS_Update(length: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_GetCPU() -> f32;
}
extern "C" {
    pub fn BASS_Start() -> BOOL;
}
extern "C" {
    pub fn BASS_Stop() -> BOOL;
}
extern "C" {
    pub fn BASS_Pause() -> BOOL;
}
extern "C" {
    pub fn BASS_IsStarted() -> BOOL;
}
extern "C" {
    pub fn BASS_SetVolume(volume: f32) -> BOOL;
}
extern "C" {
    pub fn BASS_GetVolume() -> f32;
}
extern "C" {
    pub fn BASS_PluginLoad(file: *const ::std::os::raw::c_char, flags: DWORD) -> HPLUGIN;
}
extern "C" {
    pub fn BASS_PluginFree(handle: HPLUGIN) -> BOOL;
}
extern "C" {
    pub fn BASS_PluginGetInfo(handle: HPLUGIN) -> *const BASS_PLUGININFO;
}
extern "C" {
    pub fn BASS_Set3DFactors(distf: f32, rollf: f32, doppf: f32) -> BOOL;
}
extern "C" {
    pub fn BASS_Get3DFactors(distf: *mut f32, rollf: *mut f32, doppf: *mut f32) -> BOOL;
}
extern "C" {
    pub fn BASS_Set3DPosition(
        pos: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
        front: *const BASS_3DVECTOR,
        top: *const BASS_3DVECTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_Get3DPosition(
        pos: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
        front: *mut BASS_3DVECTOR,
        top: *mut BASS_3DVECTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_Apply3D();
}
extern "C" {
    pub fn BASS_MusicLoad(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        flags: DWORD,
        freq: DWORD,
    ) -> HMUSIC;
}
extern "C" {
    pub fn BASS_MusicFree(handle: HMUSIC) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleLoad(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: DWORD,
        max: DWORD,
        flags: DWORD,
    ) -> HSAMPLE;
}
extern "C" {
    pub fn BASS_SampleCreate(length: DWORD, freq: DWORD, chans: DWORD, max: DWORD, flags: DWORD) -> HSAMPLE;
}
extern "C" {
    pub fn BASS_SampleFree(handle: HSAMPLE) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleSetData(handle: HSAMPLE, buffer: *const ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleGetData(handle: HSAMPLE, buffer: *mut ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleGetInfo(handle: HSAMPLE, info: *mut BASS_SAMPLE) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleSetInfo(handle: HSAMPLE, info: *const BASS_SAMPLE) -> BOOL;
}
extern "C" {
    pub fn BASS_SampleGetChannel(handle: HSAMPLE, onlynew: BOOL) -> HCHANNEL;
}
extern "C" {
    pub fn BASS_SampleGetChannels(handle: HSAMPLE, channels: *mut HCHANNEL) -> DWORD;
}
extern "C" {
    pub fn BASS_SampleStop(handle: HSAMPLE) -> BOOL;
}
extern "C" {
    pub fn BASS_StreamCreate(
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: STREAMPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM;
}
extern "C" {
    pub fn BASS_StreamCreateFile(
        mem: BOOL,
        file: *const ::std::os::raw::c_void,
        offset: QWORD,
        length: QWORD,
        flags: DWORD,
    ) -> HSTREAM;
}
extern "C" {
    pub fn BASS_StreamCreateURL(
        url: *const ::std::os::raw::c_char,
        offset: DWORD,
        flags: DWORD,
        proc_: DOWNLOADPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM;
}
extern "C" {
    pub fn BASS_StreamCreateFileUser(
        system: DWORD,
        flags: DWORD,
        proc_: *const BASS_FILEPROCS,
        user: *mut ::std::os::raw::c_void,
    ) -> HSTREAM;
}
extern "C" {
    pub fn BASS_StreamFree(handle: HSTREAM) -> BOOL;
}
extern "C" {
    pub fn BASS_StreamGetFilePosition(handle: HSTREAM, mode: DWORD) -> QWORD;
}
extern "C" {
    pub fn BASS_StreamPutData(handle: HSTREAM, buffer: *const ::std::os::raw::c_void, length: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_StreamPutFileData(handle: HSTREAM, buffer: *const ::std::os::raw::c_void, length: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_RecordGetDeviceInfo(device: DWORD, info: *mut BASS_DEVICEINFO) -> BOOL;
}
extern "C" {
    pub fn BASS_RecordInit(device: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn BASS_RecordSetDevice(device: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_RecordGetDevice() -> DWORD;
}
extern "C" {
    pub fn BASS_RecordFree() -> BOOL;
}
extern "C" {
    pub fn BASS_RecordGetInfo(info: *mut BASS_RECORDINFO) -> BOOL;
}
extern "C" {
    pub fn BASS_RecordGetInputName(input: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BASS_RecordSetInput(input: ::std::os::raw::c_int, flags: DWORD, volume: f32) -> BOOL;
}
extern "C" {
    pub fn BASS_RecordGetInput(input: ::std::os::raw::c_int, volume: *mut f32) -> DWORD;
}
extern "C" {
    pub fn BASS_RecordStart(
        freq: DWORD,
        chans: DWORD,
        flags: DWORD,
        proc_: RECORDPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HRECORD;
}
extern "C" {
    pub fn BASS_ChannelBytes2Seconds(handle: DWORD, pos: QWORD) -> f64;
}
extern "C" {
    pub fn BASS_ChannelSeconds2Bytes(handle: DWORD, pos: f64) -> QWORD;
}
extern "C" {
    pub fn BASS_ChannelGetDevice(handle: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelSetDevice(handle: DWORD, device: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelIsActive(handle: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelGetInfo(handle: DWORD, info: *mut BASS_CHANNELINFO) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetTags(handle: DWORD, tags: DWORD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BASS_ChannelFlags(handle: DWORD, flags: DWORD, mask: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelUpdate(handle: DWORD, length: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelLock(handle: DWORD, lock: BOOL) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelPlay(handle: DWORD, restart: BOOL) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelStop(handle: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelPause(handle: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSetAttribute(handle: DWORD, attrib: DWORD, value: f32) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetAttribute(handle: DWORD, attrib: DWORD, value: *mut f32) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSlideAttribute(handle: DWORD, attrib: DWORD, value: f32, time: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelIsSliding(handle: DWORD, attrib: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSetAttributeEx(handle: DWORD, attrib: DWORD, value: *mut ::std::os::raw::c_void, size: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetAttributeEx(handle: DWORD, attrib: DWORD, value: *mut ::std::os::raw::c_void, size: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelSet3DAttributes(
        handle: DWORD,
        mode: ::std::os::raw::c_int,
        min: f32,
        max: f32,
        iangle: ::std::os::raw::c_int,
        oangle: ::std::os::raw::c_int,
        outvol: f32,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGet3DAttributes(
        handle: DWORD,
        mode: *mut DWORD,
        min: *mut f32,
        max: *mut f32,
        iangle: *mut DWORD,
        oangle: *mut DWORD,
        outvol: *mut f32,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSet3DPosition(
        handle: DWORD,
        pos: *const BASS_3DVECTOR,
        orient: *const BASS_3DVECTOR,
        vel: *const BASS_3DVECTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGet3DPosition(
        handle: DWORD,
        pos: *mut BASS_3DVECTOR,
        orient: *mut BASS_3DVECTOR,
        vel: *mut BASS_3DVECTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetLength(handle: DWORD, mode: DWORD) -> QWORD;
}
extern "C" {
    pub fn BASS_ChannelSetPosition(handle: DWORD, pos: QWORD, mode: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetPosition(handle: DWORD, mode: DWORD) -> QWORD;
}
extern "C" {
    pub fn BASS_ChannelGetLevel(handle: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelGetLevelEx(handle: DWORD, levels: *mut f32, length: f32, flags: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelGetData(handle: DWORD, buffer: *mut ::std::os::raw::c_void, length: DWORD) -> DWORD;
}
extern "C" {
    pub fn BASS_ChannelSetSync(
        handle: DWORD,
        type_: DWORD,
        param: QWORD,
        proc_: SYNCPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> HSYNC;
}
extern "C" {
    pub fn BASS_ChannelRemoveSync(handle: DWORD, sync: HSYNC) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSetDSP(
        handle: DWORD,
        proc_: DSPPROC,
        user: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    ) -> HDSP;
}
extern "C" {
    pub fn BASS_ChannelRemoveDSP(handle: DWORD, dsp: HDSP) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSetLink(handle: DWORD, chan: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelRemoveLink(handle: DWORD, chan: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_ChannelSetFX(handle: DWORD, type_: DWORD, priority: ::std::os::raw::c_int) -> HFX;
}
extern "C" {
    pub fn BASS_ChannelRemoveFX(handle: DWORD, fx: HFX) -> BOOL;
}
extern "C" {
    pub fn BASS_FXSetParameters(handle: HFX, params: *const ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_FXGetParameters(handle: HFX, params: *mut ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_FXReset(handle: HFX) -> BOOL;
}
extern "C" {
    pub fn BASS_FXSetPriority(handle: HFX, priority: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_GetVersion() -> DWORD;
}
pub const BASS_FX_BFX_ROTATE: _bindgen_ty_2 = 65536;
pub const BASS_FX_BFX_ECHO: _bindgen_ty_2 = 65537;
pub const BASS_FX_BFX_FLANGER: _bindgen_ty_2 = 65538;
pub const BASS_FX_BFX_VOLUME: _bindgen_ty_2 = 65539;
pub const BASS_FX_BFX_PEAKEQ: _bindgen_ty_2 = 65540;
pub const BASS_FX_BFX_REVERB: _bindgen_ty_2 = 65541;
pub const BASS_FX_BFX_LPF: _bindgen_ty_2 = 65542;
pub const BASS_FX_BFX_MIX: _bindgen_ty_2 = 65543;
pub const BASS_FX_BFX_DAMP: _bindgen_ty_2 = 65544;
pub const BASS_FX_BFX_AUTOWAH: _bindgen_ty_2 = 65545;
pub const BASS_FX_BFX_ECHO2: _bindgen_ty_2 = 65546;
pub const BASS_FX_BFX_PHASER: _bindgen_ty_2 = 65547;
pub const BASS_FX_BFX_ECHO3: _bindgen_ty_2 = 65548;
pub const BASS_FX_BFX_CHORUS: _bindgen_ty_2 = 65549;
pub const BASS_FX_BFX_APF: _bindgen_ty_2 = 65550;
pub const BASS_FX_BFX_COMPRESSOR: _bindgen_ty_2 = 65551;
pub const BASS_FX_BFX_DISTORTION: _bindgen_ty_2 = 65552;
pub const BASS_FX_BFX_COMPRESSOR2: _bindgen_ty_2 = 65553;
pub const BASS_FX_BFX_VOLUME_ENV: _bindgen_ty_2 = 65554;
pub const BASS_FX_BFX_BQF: _bindgen_ty_2 = 65555;
pub const BASS_FX_BFX_ECHO4: _bindgen_ty_2 = 65556;
pub const BASS_FX_BFX_PITCHSHIFT: _bindgen_ty_2 = 65557;
pub const BASS_FX_BFX_FREEVERB: _bindgen_ty_2 = 65558;
pub type _bindgen_ty_2 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ROTATE {
    pub fRate: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ROTATE() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ROTATE>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_BFX_ROTATE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ROTATE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ROTATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ROTATE>())).fRate as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ROTATE), "::", stringify!(fRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ROTATE>())).lChannel as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ROTATE), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ECHO {
    pub fLevel: f32,
    pub lDelay: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ECHO() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ECHO>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_BFX_ECHO))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ECHO>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ECHO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO>())).fLevel as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO), "::", stringify!(fLevel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO>())).lDelay as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO), "::", stringify!(lDelay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_FLANGER {
    pub fWetDry: f32,
    pub fSpeed: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_FLANGER() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_FLANGER>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_BFX_FLANGER))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_FLANGER>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_FLANGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FLANGER>())).fWetDry as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FLANGER), "::", stringify!(fWetDry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FLANGER>())).fSpeed as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FLANGER), "::", stringify!(fSpeed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FLANGER>())).lChannel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FLANGER), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_VOLUME {
    pub lChannel: ::std::os::raw::c_int,
    pub fVolume: f32,
}
#[test]
fn bindgen_test_layout_BASS_BFX_VOLUME() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_VOLUME>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_BFX_VOLUME))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_VOLUME>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_VOLUME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME>())).lChannel as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_VOLUME), "::", stringify!(lChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME>())).fVolume as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_VOLUME), "::", stringify!(fVolume))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_PEAKEQ {
    pub lBand: ::std::os::raw::c_int,
    pub fBandwidth: f32,
    pub fQ: f32,
    pub fCenter: f32,
    pub fGain: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_PEAKEQ() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_PEAKEQ>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_PEAKEQ))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_PEAKEQ>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_PEAKEQ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).lBand as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(lBand))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).fBandwidth as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(fBandwidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).fQ as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(fQ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).fCenter as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(fCenter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).fGain as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PEAKEQ>())).lChannel as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PEAKEQ), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_REVERB {
    pub fLevel: f32,
    pub lDelay: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_REVERB() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_REVERB>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_BFX_REVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_REVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_REVERB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_REVERB>())).fLevel as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_REVERB), "::", stringify!(fLevel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_REVERB>())).lDelay as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_REVERB), "::", stringify!(lDelay))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_LPF {
    pub fResonance: f32,
    pub fCutOffFreq: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_LPF() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_LPF>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_BFX_LPF))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_LPF>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_LPF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_LPF>())).fResonance as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_LPF), "::", stringify!(fResonance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_LPF>())).fCutOffFreq as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_LPF), "::", stringify!(fCutOffFreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_LPF>())).lChannel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_LPF), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_MIX {
    pub lChannel: *const ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_MIX() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_MIX>(),
        8usize,
        concat!("Size of: ", stringify!(BASS_BFX_MIX))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_MIX>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_BFX_MIX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_MIX>())).lChannel as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_MIX), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_DAMP {
    pub fTarget: f32,
    pub fQuiet: f32,
    pub fRate: f32,
    pub fGain: f32,
    pub fDelay: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_DAMP() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_DAMP>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_DAMP))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_DAMP>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_DAMP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).fTarget as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(fTarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).fQuiet as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(fQuiet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).fRate as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(fRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).fGain as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).fDelay as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DAMP>())).lChannel as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DAMP), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_AUTOWAH {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fRate: f32,
    pub fRange: f32,
    pub fFreq: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_AUTOWAH() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_AUTOWAH>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_BFX_AUTOWAH))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_AUTOWAH>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_AUTOWAH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fRate as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fRange as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).fFreq as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(fFreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_AUTOWAH>())).lChannel as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_AUTOWAH), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ECHO2 {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fDelay: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ECHO2() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ECHO2>(),
        20usize,
        concat!("Size of: ", stringify!(BASS_BFX_ECHO2))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ECHO2>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ECHO2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO2>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO2), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO2>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO2), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO2>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO2), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO2>())).fDelay as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO2), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO2>())).lChannel as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO2), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_PHASER {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fRate: f32,
    pub fRange: f32,
    pub fFreq: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_PHASER() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_PHASER>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_BFX_PHASER))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_PHASER>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_PHASER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fRate as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fRange as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).fFreq as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(fFreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PHASER>())).lChannel as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PHASER), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ECHO3 {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fDelay: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ECHO3() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ECHO3>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_BFX_ECHO3))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ECHO3>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ECHO3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO3>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO3), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO3>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO3), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO3>())).fDelay as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO3), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO3>())).lChannel as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO3), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_CHORUS {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fMinSweep: f32,
    pub fMaxSweep: f32,
    pub fRate: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_CHORUS() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_CHORUS>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_BFX_CHORUS))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_CHORUS>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_CHORUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fMinSweep as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fMinSweep))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fMaxSweep as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fMaxSweep))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).fRate as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(fRate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_CHORUS>())).lChannel as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_CHORUS), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_APF {
    pub fGain: f32,
    pub fDelay: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_APF() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_APF>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_BFX_APF))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_APF>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_APF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_APF>())).fGain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_APF), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_APF>())).fDelay as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_APF), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_APF>())).lChannel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_APF), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_COMPRESSOR {
    pub fThreshold: f32,
    pub fAttacktime: f32,
    pub fReleasetime: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_COMPRESSOR() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_COMPRESSOR>(),
        16usize,
        concat!("Size of: ", stringify!(BASS_BFX_COMPRESSOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_COMPRESSOR>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_COMPRESSOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR>())).fThreshold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR),
            "::",
            stringify!(fThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR>())).fAttacktime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR),
            "::",
            stringify!(fAttacktime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR>())).fReleasetime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR),
            "::",
            stringify!(fReleasetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR>())).lChannel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR),
            "::",
            stringify!(lChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_DISTORTION {
    pub fDrive: f32,
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fVolume: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_DISTORTION() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_DISTORTION>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_DISTORTION))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_DISTORTION>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_DISTORTION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).fDrive as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_DISTORTION), "::", stringify!(fDrive))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).fDryMix as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_DISTORTION),
            "::",
            stringify!(fDryMix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).fWetMix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_DISTORTION),
            "::",
            stringify!(fWetMix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).fFeedback as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_DISTORTION),
            "::",
            stringify!(fFeedback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).fVolume as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_DISTORTION),
            "::",
            stringify!(fVolume)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_DISTORTION>())).lChannel as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_DISTORTION),
            "::",
            stringify!(lChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_COMPRESSOR2 {
    pub fGain: f32,
    pub fThreshold: f32,
    pub fRatio: f32,
    pub fAttack: f32,
    pub fRelease: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_COMPRESSOR2() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_COMPRESSOR2>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_COMPRESSOR2))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_COMPRESSOR2>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_COMPRESSOR2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).fGain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_COMPRESSOR2), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).fThreshold as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR2),
            "::",
            stringify!(fThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).fRatio as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR2),
            "::",
            stringify!(fRatio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).fAttack as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR2),
            "::",
            stringify!(fAttack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).fRelease as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR2),
            "::",
            stringify!(fRelease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_COMPRESSOR2>())).lChannel as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_COMPRESSOR2),
            "::",
            stringify!(lChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_VOLUME_ENV {
    pub lChannel: ::std::os::raw::c_int,
    pub lNodeCount: ::std::os::raw::c_int,
    pub pNodes: *const BASS_BFX_ENV_NODE,
    pub bFollow: BOOL,
}
#[test]
fn bindgen_test_layout_BASS_BFX_VOLUME_ENV() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_VOLUME_ENV>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_VOLUME_ENV))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_VOLUME_ENV>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_BFX_VOLUME_ENV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME_ENV>())).lChannel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_VOLUME_ENV),
            "::",
            stringify!(lChannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME_ENV>())).lNodeCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_VOLUME_ENV),
            "::",
            stringify!(lNodeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME_ENV>())).pNodes as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_VOLUME_ENV), "::", stringify!(pNodes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_VOLUME_ENV>())).bFollow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_VOLUME_ENV),
            "::",
            stringify!(bFollow)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ENV_NODE {
    pub pos: f64,
    pub val: f32,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ENV_NODE() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ENV_NODE>(),
        12usize,
        concat!("Size of: ", stringify!(BASS_BFX_ENV_NODE))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ENV_NODE>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ENV_NODE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ENV_NODE>())).pos as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ENV_NODE), "::", stringify!(pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ENV_NODE>())).val as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ENV_NODE), "::", stringify!(val))
    );
}
pub const BASS_BFX_BQF_LOWPASS: _bindgen_ty_3 = 0;
pub const BASS_BFX_BQF_HIGHPASS: _bindgen_ty_3 = 1;
pub const BASS_BFX_BQF_BANDPASS: _bindgen_ty_3 = 2;
pub const BASS_BFX_BQF_BANDPASS_Q: _bindgen_ty_3 = 3;
pub const BASS_BFX_BQF_NOTCH: _bindgen_ty_3 = 4;
pub const BASS_BFX_BQF_ALLPASS: _bindgen_ty_3 = 5;
pub const BASS_BFX_BQF_PEAKINGEQ: _bindgen_ty_3 = 6;
pub const BASS_BFX_BQF_LOWSHELF: _bindgen_ty_3 = 7;
pub const BASS_BFX_BQF_HIGHSHELF: _bindgen_ty_3 = 8;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_BQF {
    pub lFilter: ::std::os::raw::c_int,
    pub fCenter: f32,
    pub fGain: f32,
    pub fBandwidth: f32,
    pub fQ: f32,
    pub fS: f32,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_BQF() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_BQF>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_BFX_BQF))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_BQF>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_BQF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).lFilter as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(lFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).fCenter as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(fCenter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).fGain as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(fGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).fBandwidth as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(fBandwidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).fQ as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(fQ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).fS as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(fS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_BQF>())).lChannel as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_BQF), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_ECHO4 {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fFeedback: f32,
    pub fDelay: f32,
    pub bStereo: BOOL,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_ECHO4() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_ECHO4>(),
        24usize,
        concat!("Size of: ", stringify!(BASS_BFX_ECHO4))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_ECHO4>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_ECHO4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).fFeedback as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(fFeedback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).fDelay as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(fDelay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).bStereo as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(bStereo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_ECHO4>())).lChannel as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_ECHO4), "::", stringify!(lChannel))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_PITCHSHIFT {
    pub fPitchShift: f32,
    pub fSemitones: f32,
    pub lFFTsize: ::std::os::raw::c_long,
    pub lOsamp: ::std::os::raw::c_long,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_PITCHSHIFT() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_PITCHSHIFT>(),
        32usize,
        concat!("Size of: ", stringify!(BASS_BFX_PITCHSHIFT))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_PITCHSHIFT>(),
        8usize,
        concat!("Alignment of ", stringify!(BASS_BFX_PITCHSHIFT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PITCHSHIFT>())).fPitchShift as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_PITCHSHIFT),
            "::",
            stringify!(fPitchShift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PITCHSHIFT>())).fSemitones as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_PITCHSHIFT),
            "::",
            stringify!(fSemitones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PITCHSHIFT>())).lFFTsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_PITCHSHIFT),
            "::",
            stringify!(lFFTsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PITCHSHIFT>())).lOsamp as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_PITCHSHIFT), "::", stringify!(lOsamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_PITCHSHIFT>())).lChannel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_PITCHSHIFT),
            "::",
            stringify!(lChannel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASS_BFX_FREEVERB {
    pub fDryMix: f32,
    pub fWetMix: f32,
    pub fRoomSize: f32,
    pub fDamp: f32,
    pub fWidth: f32,
    pub lMode: DWORD,
    pub lChannel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BASS_BFX_FREEVERB() {
    assert_eq!(
        ::std::mem::size_of::<BASS_BFX_FREEVERB>(),
        28usize,
        concat!("Size of: ", stringify!(BASS_BFX_FREEVERB))
    );
    assert_eq!(
        ::std::mem::align_of::<BASS_BFX_FREEVERB>(),
        4usize,
        concat!("Alignment of ", stringify!(BASS_BFX_FREEVERB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).fDryMix as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(fDryMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).fWetMix as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(fWetMix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).fRoomSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASS_BFX_FREEVERB),
            "::",
            stringify!(fRoomSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).fDamp as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(fDamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).fWidth as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(fWidth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).lMode as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(lMode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BASS_BFX_FREEVERB>())).lChannel as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(BASS_BFX_FREEVERB), "::", stringify!(lChannel))
    );
}
pub const BASS_ATTRIB_TEMPO: _bindgen_ty_4 = 65536;
pub const BASS_ATTRIB_TEMPO_PITCH: _bindgen_ty_4 = 65537;
pub const BASS_ATTRIB_TEMPO_FREQ: _bindgen_ty_4 = 65538;
pub type _bindgen_ty_4 = u32;
pub const BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER: _bindgen_ty_5 = 65552;
pub const BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH: _bindgen_ty_5 = 65553;
pub const BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO: _bindgen_ty_5 = 65554;
pub const BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS: _bindgen_ty_5 = 65555;
pub const BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS: _bindgen_ty_5 = 65556;
pub const BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS: _bindgen_ty_5 = 65557;
pub const BASS_ATTRIB_TEMPO_OPTION_PREVENT_CLICK: _bindgen_ty_5 = 65558;
pub type _bindgen_ty_5 = u32;
extern "C" {
    pub fn BASS_FX_TempoCreate(chan: DWORD, flags: DWORD) -> HSTREAM;
}
extern "C" {
    pub fn BASS_FX_TempoGetSource(chan: HSTREAM) -> DWORD;
}
extern "C" {
    pub fn BASS_FX_TempoGetRateRatio(chan: HSTREAM) -> f32;
}
extern "C" {
    pub fn BASS_FX_ReverseCreate(chan: DWORD, dec_block: f32, flags: DWORD) -> HSTREAM;
}
extern "C" {
    pub fn BASS_FX_ReverseGetSource(chan: HSTREAM) -> DWORD;
}
pub const BASS_FX_BPM_TRAN_X2: _bindgen_ty_6 = 0;
pub const BASS_FX_BPM_TRAN_2FREQ: _bindgen_ty_6 = 1;
pub const BASS_FX_BPM_TRAN_FREQ2: _bindgen_ty_6 = 2;
pub const BASS_FX_BPM_TRAN_2PERCENT: _bindgen_ty_6 = 3;
pub const BASS_FX_BPM_TRAN_PERCENT2: _bindgen_ty_6 = 4;
pub type _bindgen_ty_6 = u32;
pub type BPMPROC = ::std::option::Option<unsafe extern "C" fn(chan: DWORD, bpm: f32, user: *mut ::std::os::raw::c_void)>;
pub type BPMPROGRESSPROC =
    ::std::option::Option<unsafe extern "C" fn(chan: DWORD, percent: f32, user: *mut ::std::os::raw::c_void)>;
pub type BPMPROCESSPROC = BPMPROGRESSPROC;
extern "C" {
    pub fn BASS_FX_BPM_DecodeGet(
        chan: DWORD,
        startSec: f64,
        endSec: f64,
        minMaxBPM: DWORD,
        flags: DWORD,
        proc_: BPMPROGRESSPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> f32;
}
extern "C" {
    pub fn BASS_FX_BPM_CallbackSet(
        handle: DWORD,
        proc_: BPMPROC,
        period: f64,
        minMaxBPM: DWORD,
        flags: DWORD,
        user: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_CallbackReset(handle: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_Translate(handle: DWORD, val2tran: f32, trans: DWORD) -> f32;
}
extern "C" {
    pub fn BASS_FX_BPM_Free(handle: DWORD) -> BOOL;
}
pub type BPMBEATPROC = ::std::option::Option<unsafe extern "C" fn(chan: DWORD, beatpos: f64, user: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn BASS_FX_BPM_BeatCallbackSet(handle: DWORD, proc_: BPMBEATPROC, user: *mut ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_BeatCallbackReset(handle: DWORD) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_BeatDecodeGet(
        chan: DWORD,
        startSec: f64,
        endSec: f64,
        flags: DWORD,
        proc_: BPMBEATPROC,
        user: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_BeatSetParameters(handle: DWORD, bandwidth: f32, centerfreq: f32, beat_rtime: f32) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_BeatGetParameters(handle: DWORD, bandwidth: *mut f32, centerfreq: *mut f32, beat_rtime: *mut f32) -> BOOL;
}
extern "C" {
    pub fn BASS_FX_BPM_BeatFree(handle: DWORD) -> BOOL;
}
